# OptimizationServer (Julia)

This project implements a lightweight socket-based optimization server. It receives optimization problems (e.g. LP, QP) encoded in Arrow IPC format via TCP, solves them using JuMP and solver backends, and returns the result. The server listens for incoming socket connections and sends optimization results serialized in Arrow IPC format.

## ðŸ“ Project Structure
```
julia/
â”œâ”€â”€ controller/ # Request listener/controller
â”‚ â””â”€â”€ socket_server.jl # TCP socket server (entry controller)
â”‚
â”œâ”€â”€ model/ # Optimization model definitions
â”‚ â”œâ”€â”€ lp_model.jl
â”‚ â””â”€â”€ qp_model.jl
â”‚
â”œâ”€â”€ service/ # Business logic and factories
â”‚ â”œâ”€â”€ model_factory.jl # Maps model type strings to model modules
â”‚ â”œâ”€â”€ solver_factory.jl # Maps solver name to JuMP optimizer
â”‚ â””â”€â”€ optimization_service.jl # Core compute logic
â”‚
â”œâ”€â”€ utils/ # Reusable I/O and math helpers
â”‚ â”œâ”€â”€ io_utils.jl # Arrow serialization, TCP helpers
â”‚ â””â”€â”€ sparse_matrix.jl # Sparse array converters
â”‚
â”œâ”€â”€ engine.jl # Project entry point
â”œâ”€â”€ Project.toml
â””â”€â”€ Manifest.toml
```



## ðŸš€ Getting Started

### 1.  Launch Julia in project mode
```julia --project=.```
This tells Julia to use the current folder's environment (Project.toml + Manifest.toml).

### 2. Install dependencies (only needed the first time)
```julia```

Once inside Julia REPL:

```julia> ]```
```(pkg) instantiate```

### 3. Start the server directly from terminal:

```julia --project=. engine.jl```

You should see:
```Listening on 127.0.0.1:65432```

